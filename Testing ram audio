
#include <Arduino.h>
#include <Wire.h>
#include <Adafruit_MCP23X17.h>
#include <Adafruit_NeoPixel.h>
#include <LittleFS.h>
#include "driver/i2s.h"
#include "esp_heap_caps.h"
#ifdef __AVR__
 #include <avr/power.h> // Required for 16 MHz Adafruit Trinket
#endif

// How many NeoPixels are attached to the Arduino?
#define LED_COUNT 100

board_build.psram = enabled

//Bus one pins
#define I2C_SDA0 16
#define I2C_SCL0 15 //SCK
//Bus two pins
#define I2C_SDA1 18
#define I2C_SCL1 17

#define EMPTY 0
//#define SHIP  1
#define boardSize 10
#define maxShips 5
#define maxShipSize 4
#define mcpBaseAddress 0x20

#define orca 2
#define sub 3
#define AOPS 6
#define frigate 4
#define JSS 5

Adafruit_MCP23X17 mcp0[8];
Adafruit_MCP23X17 mcp1[8];

TwoWire I2C_0 = TwoWire(0);
TwoWire I2C_1 = TwoWire(1);

#define Ping_Sound 0
#define Whistle_Sound 1
#define Bloop_Sound 2
#define Hit_Sound 3
#define Miss_Sound 4
#define Sunk_Sound 5
#define Victory_Sound 6
#define Volume_Sound 7
#define Brightness_Sound 8
#define Halifax_Sound 9
#define AOPS_Sound 10
#define Orca_Sound 11
#define JSS_Sound 12
#define Sub_Sound 13
#define Fleet_Destroyed_Sound 14
#define Deploy_Sound 15
#define P1_Deployed_Sound 16
#define P2_Deployed_Sound 17
#define Set_Coordinates_Sound 18
#define Single_Player_Sound 19
#define Whilhelm_Sound 20
#define Coordinates_Locked_Sound 21

// -------- PLAYER 1 PINS --------
#define P1_GREEN_BTN   42
#define P1_RED_BTN     41
#define P1_GREEN_LED   40
#define P1_RED_LED     39
#define P1_POT_ROW     6
#define P1_POT_COL     7
#define P1_LED_PIN1     4   // NeoPixel data pin
#define P1_LED_PIN2     8

// -------- PLAYER 2 PINS --------
#define P2_GREEN_BTN   38
#define P2_RED_BTN     37
#define P2_GREEN_LED   36
#define P2_RED_LED     35
#define P2_POT_ROW     9
#define P2_POT_COL     10
#define P2_LED_PIN1     1
#define P2_LED_PIN2     2

// ===== Pins (ESP32-S3 DevKitC-1) =====
static const int I2S_BCLK = 12;
static const int I2S_LRC  = 13;
static const int I2S_DOUT = 14;
static const int POT_PIN  = 5;

TaskHandle_t audioTask;
TaskHandle_t hitTask;
TaskHandle_t missTask;
volatile int audioFile = -1;

enum Player {
  PLAYER_1 = 0,
  PLAYER_2 = 1
};

enum GameState {
  WAITING_FOR_AIM,
  STALL,
  WAITING_FOR_CONFIRM,
  GAME_OVER,
};

Player activePlayer = PLAYER_2;
GameState gameState = WAITING_FOR_AIM;

Player otherPlayer(Player p) {
  return (p == PLAYER_1) ? PLAYER_2 : PLAYER_1;
}

const uint8_t gpioPinArray[boardSize][boardSize] = {
  {0,1,2,3,4,5,6,8,9,10},
  {5,4,3,2,1,0,14,13,12,11},
  {6,8,9,10,11,12,13,14,0,1},
  {12,11,10,9,8,6,5,4,3,2},
  {13,14,0,1,2,3,4,5,6,8},
  {3,2,1,0,14,13,12,11,10,9},
  {4,5,6,8,9,10,11,12,13,14},
  {10,9,8,6,5,4,3,2,1,0},
  {11,12,13,14,0,1,2,3,4,5},
  {1,0,14,13,12,11,10,9,8,6}
};

const uint8_t gpioDeviceArray[boardSize][boardSize]{
  {0,0,0,0,0,0,0,0,0,0}, //A
  {1,1,1,1,1,1,0,0,0,0}, //B
  {1,1,1,1,1,1,1,1,2,2}, //C
  {2,2,2,2,2,2,2,2,2,2}, //D
  {2,2,3,3,3,3,3,3,3,3}, //E
  {4,4,4,4,3,3,3,3,3,3}, //F
  {4,4,4,4,4,4,4,4,4,4}, //G
  {5,5,5,5,5,5,5,5,5,5}, //H
  {5,5,5,5,6,6,6,6,6,6}, //I
  {7,7,6,6,6,6,6,6,6,6}, //J
};

struct Board {
  int ships[10][10];
  bool found[10][10];
  int remaining = 0;
};

Board boards[2];

void detectShipPositions(Board &b, Adafruit_MCP23X17 mcpDevice[]);

void initrandomMatrix(Board &b);


struct PlayerHW {
  Adafruit_NeoPixel strip1;
  Adafruit_NeoPixel strip2;
  int potRowPin;
  int potColPin;
  int greenBtn;
  int redBtn;
  int greenLED;
  int redLED;

  int inputRow;
  int inputCol;
  bool aimingActive;
  uint32_t previousColors1[LED_COUNT];
  uint32_t previousColors2[LED_COUNT];
};

PlayerHW players[2] = {
  {
    Adafruit_NeoPixel(LED_COUNT, P1_LED_PIN1, NEO_GRB + NEO_KHZ800),
    Adafruit_NeoPixel(LED_COUNT, P1_LED_PIN2, NEO_GRB + NEO_KHZ800),
    P1_POT_ROW, P1_POT_COL,
    P1_GREEN_BTN, P1_RED_BTN,
    P1_GREEN_LED, P1_RED_LED,
    -1, -1, false
  },
  {
    Adafruit_NeoPixel(LED_COUNT, P2_LED_PIN1, NEO_GRB + NEO_KHZ800),
    Adafruit_NeoPixel(LED_COUNT, P2_LED_PIN2, NEO_GRB + NEO_KHZ800),
    P2_POT_ROW, P2_POT_COL,
    P2_GREEN_BTN, P2_RED_BTN,
    P2_GREEN_LED, P2_RED_LED,
    -1, -1, false
  }
};

struct WavRam {
  uint32_t sampleRate = 0;
  uint32_t len = 0;
  uint8_t* data = nullptr;
};
WavRam PingRam;
WavRam WhistleRam;
WavRam BloopRam;
WavRam HitRam;
WavRam MissRam;
WavRam SunkRam;
WavRam VictoryRam;
WavRam VolumeRam;
WavRam BrightnessRam;
WavRam HalifaxRam;
WavRam HDWRam;
WavRam OrcaRam;
WavRam ProtectorRam;
WavRam SubRam;
WavRam Fleet_DestroyedRam;
WavRam DeployRam;
WavRam P1_DeployedRam;
WavRam P2_DeployedRam;
WavRam Set_CoordinatesRam;
WavRam Single_PlayerRam;
WavRam WhilhelmRam;
WavRam Coordinates_LockedRam;

// ===== Playlist (match your uploaded names exactly) =====
static const char* kPlaylist[] = {
  "/audio/airport-radar-ping-1582.wav",
  "/audio/pipes.wav",
  "/audio/liquid-bubble-3000.wav",
  "/audio/hit.wav",
  "/audio/miss.wav",
  "/audio/sunk.wav",
  "/audio/victory.wav",
  "/audio/set_volume.wav",
  "/audio/set_brightness.wav",
  "/audio/ysa_halifax_class_frigate.wav",
  "/audio/ysa_hary_dewolf_class_A-ops.wav",
  "/audio/ysa_orca_class_patro_vessel.wav",
  "/audio/ysa_protector_class_JSS.wav",
  "/audio/ysa_victoria_class_subarine.wav",
  "/audio/enemy_fleet_destroyed.wav",
  "/audio/fleet_commanders_deploy_your_fleet.wav",
  "/audio/fleet_one_deployed.wav",
  "/audio/fleet_two_deployed.wav",
  "/audio/set_coordinance.wav",
  "/audio/single_player_mode.wav",
  "/audio/Wilhelm scream.wav",
  "/audio/corordinance_locked_in_fire_when_ready.wav"
};


struct WavInfo;
static bool parseWav(File &f, WavInfo &w);

// ===== WAV parsing =====
struct WavInfo {
  uint32_t sampleRate = 0;
  uint16_t numChannels = 0;
  uint16_t bitsPerSample = 0;
  uint32_t dataOffset = 0;
  uint32_t dataSize = 0;
};

// ===== I2S =====
static uint32_t g_rate = 0;

void refreshAimColors(PlayerHW &pl);
void refreshOceanColors(PlayerHW &pl);
void saveColors(PlayerHW &pl);
void aiming(PlayerHW &pl);
void blinkIndicatorR(PlayerHW &pl);
void blinkIndicatorG(PlayerHW &pl);
void hitLightUp(PlayerHW &pl, int r, int c);
void missLightUp(PlayerHW &pl, int r, int c);
bool commitShot(PlayerHW &pl);
void preaim(PlayerHW &pl);
void updateRipple();
void startRipple(PlayerHW &pl, int r, int c);
bool loadWavToRam(const char* path, WavRam& out);
bool playWavRam(const WavRam& w);

int y = 0;

// User inputs
int preInputRow = -1;
int preInputCol = -1;
char displayRow;
int displayCol;

bool aimingActive = false;
unsigned long lastAimUpdate = 0;
int aimStep = 0;
int aimMax = 0;
int aimRow = 0;
int aimCol = 0;
int potVal1 = 0;
int potVal2 = 0;
uint8_t brightness = 0;
float volume = 0.75;
bool singlePlayer = false;
bool stripUpdate = false;
int ripplePlayer = -1;

int sensorValue = 0;

// --- Ocean animation state ---
bool oceanActive = false;
unsigned long lastOceanUpdate = 0;
float oceanTime = 0.0;
int storm = 0;

// --- Ripple animation state ---
bool rippleActive = false;
unsigned long lastRippleUpdate = 0;

int rippleRow = 0;
int rippleCol = 0;

float rippleRadius = 0.0;
float rippleStrength = 1.0;

const char* Ping = kPlaylist[0];
const char* Whistle = kPlaylist[1];
const char* Bloop = kPlaylist[2];
const char* Hit = kPlaylist[3];
const char* Miss = kPlaylist[4];
const char* Sunk = kPlaylist[5];
const char* Victory = kPlaylist[6];
const char* Volume = kPlaylist[7];
const char* Brightness = kPlaylist[8];
const char* Halifax = kPlaylist[9];
const char* HDW = kPlaylist[10];
const char* Orca = kPlaylist[11];
const char* Protector = kPlaylist[12];
const char* Sub = kPlaylist[13];
const char* Fleet_Destroyed = kPlaylist[14];
const char* Deploy = kPlaylist[15];
const char* P1_Deployed = kPlaylist[16];
const char* P2_Deployed = kPlaylist[17];
const char* Set_Coordinates = kPlaylist[18];
const char* Single_Player = kPlaylist[19];
const char* Whilhelm = kPlaylist[20];
const char* Coordinates_Locked = kPlaylist[21];




void setup() {
  #if defined(__AVR_ATtiny85__) && (F_CPU == 16000000)
  clock_prescale_set(clock_div_1);
  #endif

  Serial.begin(115200);
  pinMode(POT_PIN, INPUT);
  I2C_0.begin(I2C_SDA0, I2C_SCL0, 400000); // Set the I2C pins. Enables the pull-up resistors.
  I2C_1.begin(I2C_SDA1, I2C_SCL1, 400000);

  Serial.printf("PSRAM size: %u bytes\n", ESP.getPsramSize());
  Serial.printf("PSRAM free: %u bytes\n", ESP.getFreePsram());

 for(uint8_t i = 0; i < 8; i++){
    uint8_t address = mcpBaseAddress + i;
    if(!mcp0[i].begin_I2C(address, &I2C_0)){
      Serial.print("Failed to initialize MCP at 0x");
      Serial.println(address, HEX);
      while(1);
    }
  }
  
  for(uint8_t i = 0; i < 8; i++){
    uint8_t address = mcpBaseAddress + i;
    if(!mcp1[i].begin_I2C(address, &I2C_1)){
      Serial.print("Failed to initialize MCP at 0x");
      Serial.println(address, HEX);
      while(1);
    }
  }

  for (int p = 0; p < 2; p++) {
    players[p].strip1.begin();
    players[p].strip2.begin();
    for (int i = 0; i < LED_COUNT; i++) {
      players[p].strip1.setPixelColor(i, 0, 0, 255);
    }
    for (int i = 0; i < LED_COUNT; i++) {
      players[p].strip2.setPixelColor(i, 5, 75, 5);
    }
    players[p].strip1.setBrightness(255);
    players[p].strip2.setBrightness(255);
    players[p].strip1.show();
    players[p].strip2.show();

    pinMode(players[p].greenBtn, INPUT_PULLUP);
    pinMode(players[p].redBtn, INPUT_PULLUP);
    pinMode(players[p].greenLED, OUTPUT);
    pinMode(players[p].redLED, OUTPUT);

    digitalWrite(players[p].greenLED, LOW);
    digitalWrite(players[p].redLED, LOW);
  }

  xTaskCreatePinnedToCore(
    AudioTaskCode,
    "audioTask",
    25000,
    NULL,
    0,
    &audioTask,
    0
  );

  //initilizeGPIOPins();
 
  LittleFS.begin();
/*
  loadWavToRam(Ping,               PingRam);
  loadWavToRam(Whistle,            WhistleRam);
  loadWavToRam(Bloop,              BloopRam);
  loadWavToRam(Hit,                HitRam);
  loadWavToRam(Miss,               MissRam);
  loadWavToRam(Sunk,               SunkRam);
  loadWavToRam(Victory,            VictoryRam);
  loadWavToRam(Volume,             VolumeRam);
  loadWavToRam(Brightness,         BrightnessRam);
  loadWavToRam(Halifax,            HalifaxRam);
  loadWavToRam(HDW,                HDWRam);
  loadWavToRam(Orca,               OrcaRam);
  loadWavToRam(Protector,          ProtectorRam);
  loadWavToRam(Sub,                SubRam);
  loadWavToRam(Fleet_Destroyed,    Fleet_DestroyedRam);
  loadWavToRam(Deploy,             DeployRam);
  loadWavToRam(P1_Deployed,        P1_DeployedRam);
  loadWavToRam(P2_Deployed,        P2_DeployedRam);
  loadWavToRam(Set_Coordinates,    Set_CoordinatesRam);
  loadWavToRam(Single_Player,      Single_PlayerRam);
  loadWavToRam(Whilhelm,           WhilhelmRam);
  loadWavToRam(Coordinates_Locked, Coordinates_LockedRam);
*/

  // --- Preload all WAVs into RAM/PSRAM (call after LittleFS.begin()) ---
  delay(5000);
  if (!loadWavToRam(Ping, PingRam)) {
    Serial.println("Ping preload failed!");
  }
  if (!loadWavToRam(Whistle, WhistleRam)) {
    Serial.println("Whistle preload failed!");
  }
  if (!loadWavToRam(Bloop, BloopRam)) {
    Serial.println("Bloop preload failed!");
  }
  if (!loadWavToRam(Volume, VolumeRam)) {
    Serial.println("Volume preload failed!");
  }
  if (!loadWavToRam(Brightness, BrightnessRam)) {
    Serial.println("Brightness preload failed!");
  }
  if (!loadWavToRam(Hit, HitRam)) {
    Serial.println("Hit preload failed!");
  }
  if (!loadWavToRam(Miss, MissRam)) {
    Serial.println("Miss preload failed!");
  }
  if (!loadWavToRam(Sunk, SunkRam)) {
    Serial.println("Sunk preload failed!");
  }
  if (!loadWavToRam(Victory, VictoryRam)) {
    Serial.println("Victory preload failed!");
  }
  if (!loadWavToRam(Halifax, HalifaxRam)) {
    Serial.println("Halifax preload failed!");
  }
  if (!loadWavToRam(HDW, HDWRam)) {
    Serial.println("HDW preload failed!");
  }
  if (!loadWavToRam(Orca, OrcaRam)) {
    Serial.println("Orca preload failed!");
  }
  if (!loadWavToRam(Protector, ProtectorRam)) {
    Serial.println("Protector preload failed!");
  }
  if (!loadWavToRam(Sub, SubRam)) {
    Serial.println("Sub preload failed!");
  }
  if (!loadWavToRam(Fleet_Destroyed, Fleet_DestroyedRam)) {
    Serial.println("Fleet_Destroyed preload failed!");
  }
  if (!loadWavToRam(Deploy, DeployRam)) {
    Serial.println("Deploy preload failed!");
  }
  if (!loadWavToRam(P1_Deployed, P1_DeployedRam)) {
    Serial.println("P1_Deployed preload failed!");
  }
  if (!loadWavToRam(P2_Deployed, P2_DeployedRam)) {
    Serial.println("P2_Deployed preload failed!");
  }
  if (!loadWavToRam(Set_Coordinates, Set_CoordinatesRam)) {
    Serial.println("Set_Coordinates preload failed!");
  }
  if (!loadWavToRam(Single_Player, Single_PlayerRam)) {
    Serial.println("Single_Player preload failed!");
  }
  if (!loadWavToRam(Whilhelm, WhilhelmRam)) {
    Serial.println("Whilhelm preload failed!");
  }
  if (!loadWavToRam(Coordinates_Locked, Coordinates_LockedRam)) {
    Serial.println("Coordinates_Locked preload failed!");
  }
  randomSeed(analogRead(A0));

  audioFile = Volume_Sound;
  setVolume();

  audioFile = Brightness_Sound;
  setBrightness();

  startOcean();
  audioFile = Deploy_Sound;

/*
  delay(200);

  while(boards[0].remaining == 0 || boards[1].remaining == 0){
    blinkIndicatorG(players[0]);
    blinkIndicatorR(players[1]);

    if(digitalRead(P1_GREEN_BTN) == LOW){
      detectShipPositions(boards[0], mcp0);
      //boards[0].remaining = 17;
      Serial.print("board 0 remaining: ");
      Serial.println(boards[0].remaining);
      audioFile = P1_Deployed_Sound;
    }
    if(digitalRead(P2_RED_BTN) == LOW){
      detectShipPositions(boards[1], mcp1);
      //boards[1].remaining = 17;
      Serial.print("board 1 remaining: ");
      Serial.println(boards[1].remaining);
      audioFile = P2_Deployed_Sound;
    }
  }
*/

  detectShipPositions(boards[0], mcp0);
  audioFile = P1_Deployed_Sound;
 
  detectShipPositions(boards[1], mcp1);
  audioFile = P2_Deployed_Sound;
  
  //initrandomMatrix(boards[2]);

  saveColors(players[0]);
  saveColors(players[1]);
  if(audioFile == P2_Deployed_Sound){
    delay(2500);
  }
  printShipPositions();
  audioFile = Whistle_Sound;
  digitalWrite(P1_RED_LED, LOW);
  digitalWrite(P1_GREEN_LED, LOW);

  Serial.println("Starting Game");
  stripUpdate = true;

}

void loop() {

  PlayerHW &pl = players[activePlayer];
  if(gameState != STALL){
    pl.inputRow = getPosition(pl.potRowPin);
    pl.inputCol = getPosition(pl.potColPin);
  }

  bool green = buttonPressed(pl.greenBtn);

  bool red   = buttonPressed(pl.redBtn);

  switch (gameState) {

    case WAITING_FOR_AIM:
      blinkIndicatorG(pl);
      if (green) {
        gameState = WAITING_FOR_CONFIRM;
        digitalWrite(pl.greenLED, HIGH);
      }
      if(pl.inputRow != preInputRow || pl.inputCol != preInputCol){
        refreshAimColors(pl);
      }
      preaim(pl);
      break;

    case WAITING_FOR_CONFIRM:
      aiming(pl);
      blinkIndicatorR(pl);
      if (red) {
        refreshAimColors(pl);
        pl.strip2.show();
        bool hit = commitShot(pl);
        aimingActive = false;

        if (!hit) {
          //endTurn();              // miss → switch player
          digitalWrite(pl.redLED, LOW);
          digitalWrite(pl.greenLED, LOW);
          gameState = STALL;
        } else if(gameState != GAME_OVER) {
          gameState = STALL;  // hit → same player aims again
          digitalWrite(pl.redLED, LOW);
          digitalWrite(pl.greenLED, LOW);
        }
      }
        if(pl.inputRow != preInputRow || pl.inputCol != preInputCol){
          gameState = WAITING_FOR_AIM;
          aimingActive = false;
          refreshAimColors(pl);
        }
    break;

    case STALL:
      break;

    case GAME_OVER:
      break;

  }
  preInputRow = pl.inputRow;
  preInputCol = pl.inputCol;
  updateOcean();
  updateRipple();
  if(stripUpdate == true){
    stripShow();
    stripUpdate = false;
  }
}

void HitTaskCode(void * parameter){
  PlayerHW &pl = players[activePlayer];
  vTaskDelay(3400);
  hitLightUp(pl, pl.inputRow, pl.inputCol);
  vTaskDelete(NULL);
}

void MissTaskCode(void * parameter){
  PlayerHW &pl = players[activePlayer];
  vTaskDelay(3400);
  missLightUp(pl, pl.inputRow, pl.inputCol);
  vTaskDelete(NULL);
}

void AudioTaskCode(void * parameter){
  for(;;){
    switch (audioFile) {
        case Ping_Sound:
          playWavRam(PingRam);
          //playWav(Ping);
          if (audioFile == Ping_Sound) {
            audioFile = -1;
          }
          break;
      
        case Whistle_Sound:
          //playWavRam(Whistle);
          playWavRam(WhistleRam);
          if (audioFile == Whistle_Sound) {
            audioFile = -1;
          }
          break;
      
        case Bloop_Sound:
          playWavRam(BloopRam);
          if (audioFile == Bloop_Sound) {
            audioFile = -1;
          }
          break;
      
        case Hit_Sound:
          playWavRam(HitRam);
          if (audioFile == Hit_Sound) {
            audioFile = -1;
          }
          break;
      
        case Miss_Sound:
          playWavRam(MissRam);
          if (audioFile == Miss_Sound) {
            audioFile = -1;
          }
          break;
      
        case Sunk_Sound:
          playWavRam(SunkRam);
          if (audioFile == Sunk_Sound) {
            audioFile = -1;
          }
          break;
      
        case Victory_Sound:
          playWavRam(VictoryRam);
          if (audioFile == Victory_Sound) {
            audioFile = -1;
          }
          break;
      
        case Volume_Sound:
          playWavRam(VolumeRam);
          if (audioFile == Volume_Sound) {
            audioFile = -1;
          }
          break;
      
        case Brightness_Sound:
          playWavRam(BrightnessRam);
          if (audioFile == Brightness_Sound) {
            audioFile = -1;
          }
          break;
      
        case Halifax_Sound:
          playWavRam(HalifaxRam);
          if (audioFile == Halifax_Sound) {
            audioFile = -1;
          }
          break;
      
        case AOPS_Sound:
          playWavRam(HDWRam);
          if (audioFile == AOPS_Sound) {
            audioFile = -1;
          }
          break;
      
        case Orca_Sound:
          playWavRam(OrcaRam);
          if (audioFile == Orca_Sound) {
            audioFile = -1;
          }
          break;
      
        case JSS_Sound:
          playWavRam(ProtectorRam);
          if (audioFile == JSS_Sound) {
            audioFile = -1;
          }
          break;
      
        case Sub_Sound:
          playWavRam(SubRam);
          if (audioFile == Sub_Sound) {
            audioFile = -1;
          }
          break;
      
        case Fleet_Destroyed_Sound:
          playWavRam(Fleet_DestroyedRam);
          if (audioFile == Fleet_Destroyed_Sound) {
            audioFile = -1;
          }
          break;
      
        case Deploy_Sound:
          playWavRam(DeployRam);
          if (audioFile == Deploy_Sound) {
            audioFile = -1;
          }
          break;
      
        case P1_Deployed_Sound:
          playWavRam(P1_DeployedRam);
          if (audioFile == P1_Deployed_Sound) {
            audioFile = -1;
          }
          break;
      
        case P2_Deployed_Sound:
          playWavRam(P2_DeployedRam);
          if (audioFile == P2_Deployed_Sound) {
            audioFile = -1;
          }
          break;
      
        case Set_Coordinates_Sound:
          playWavRam(Set_CoordinatesRam);
          if (audioFile == Set_Coordinates_Sound) {
            audioFile = -1;
          }
          break;
      
        case Single_Player_Sound:
          playWavRam(Single_PlayerRam);
          if (audioFile == Single_Player_Sound) {
            audioFile = -1;
          }
          break;
      
        case Whilhelm_Sound:
          playWavRam(WhilhelmRam);
          if (audioFile == Whilhelm_Sound) {
            audioFile = -1;
          }
          break;
      
        case Coordinates_Locked_Sound:
          playWavRam(Coordinates_LockedRam);
          if (audioFile == Coordinates_Locked_Sound) {
            audioFile = -1;
          }
          break;
      
        default:
          break;
    }
    vTaskDelay(1);
  }
}

void endTurn() {
  aimingActive = false;
  players[activePlayer].inputRow = -1;
  players[activePlayer].inputCol = -1;
  activePlayer = otherPlayer(activePlayer);
  gameState = WAITING_FOR_AIM;
}

void stripShow() {
  players[0].strip1.show();
  players[0].strip2.show();
  players[1].strip1.show();
  players[1].strip2.show();
}

// --- Matrix Initialization --- //
void initrandomMatrix(Board &b) {
  memset(b.ships, 0, sizeof(b.ships));
  memset(b.found, 0, sizeof(b.found));
  b.remaining = 0;

  struct Block { int len; };
  Block blocks[] = {{5}, {4}, {3}, {3}, {2}};

  for (auto &blk : blocks) {
    bool placed = false;
    while (!placed) {
      int len = blk.len;
      bool horiz = random(2);
      int line = random(10);
      int start = random(0, 10 - len);

      bool ok = true;
      for (int i = 0; i < len; i++) {
        int r = horiz ? line : start + i;
        int c = horiz ? start + i : line;
        if (b.ships[r][c]) { ok = false; break; }
      }
      if (!ok) continue;

      for (int i = 0; i < len; i++) {
        int r = horiz ? line : start + i;
        int c = horiz ? start + i : line;
        b.ships[r][c] = 1;
      }
      b.remaining += len;
      placed = true;
    }
  }
}



void saveColors(PlayerHW &pl){
  for ( int i = 0; i < LED_COUNT; i++){
    pl.previousColors1[i] = pl.strip1.getPixelColor(i);
  }
  for ( int i = 0; i < LED_COUNT; i++){
    pl.previousColors2[i] = pl.strip2.getPixelColor(i);
  }
}

void refreshAimColors(PlayerHW &pl){
  for ( int i = 0; i < LED_COUNT; i++){
    pl.strip2.setPixelColor(i, pl.previousColors2[i]);
  }
  stripUpdate = true;
}

void refreshOceanColors(PlayerHW &pl){
  for ( int i = 0; i < LED_COUNT; i++){
    pl.strip1.setPixelColor(i, pl.previousColors1[i]);
  }
  stripUpdate = true;
}

void preaim(PlayerHW &pl){
  int refRow = 0;
  int refCol = 0;
  pl.strip2.setPixelColor(indexConvert(pl.inputRow, refCol), 255, 255, 0);
  pl.strip2.setPixelColor(indexConvert(refRow, pl.inputCol), 255, 255, 0);
  stripUpdate = true;
}


// --- Aiming --- //
void aiming(PlayerHW &pl){
  if (!aimingActive) {
    // Start a new aiming animation
    aimingActive = true;
    aimRow = pl.inputRow;
    aimCol = pl.inputCol;
    aimStep = 0;
    aimMax = max(max(9 - aimCol, aimCol), max(9 - aimRow, aimRow));
    lastAimUpdate = millis();
    refreshAimColors(pl);
    return;
  }

  // Update animation step (every 50 ms)
  if (millis() - lastAimUpdate >= 80) {
    lastAimUpdate = millis();

    refreshAimColors(pl); // restore base colors before drawing current step

    pl.strip2.setPixelColor(indexConvert(pl.inputRow, pl.inputCol), 255, 255, 0);

    int i = aimMax - aimStep;
    if (i <= (9 - aimCol)) pl.strip2.setPixelColor(indexConvert(aimRow, aimCol + i), 255, 255, 0);
    if (i <= aimCol)       pl.strip2.setPixelColor(indexConvert(aimRow, aimCol - i), 255, 255, 0);
    if (i <= aimRow)       pl.strip2.setPixelColor(indexConvert(aimRow - i, aimCol), 255, 255, 0);
    if (i <= (9 - aimRow)) pl.strip2.setPixelColor(indexConvert(aimRow + i, aimCol), 255, 255, 0);

    aimStep++;

    // Once done, highlight target and stop animation
    if (aimStep > aimMax) {
      refreshAimColors(pl);
      aimingActive = false;
      audioFile = Ping_Sound; 
    }
    stripUpdate = true;
  }
}


// --- Red Indicator LED blink --- //
void blinkIndicatorR(PlayerHW &pl) {
  static unsigned long rPrevBlink = 0;
  static bool rStateBlink = false;
  if (millis() - rPrevBlink > 100) {
    rPrevBlink = millis();
    rStateBlink = !rStateBlink;
    digitalWrite(pl.redLED, rStateBlink);
  }
}

// --- Green Indicator LED blink --- //
void blinkIndicatorG(PlayerHW &pl) {
  static unsigned long gPrevBlink = 0;
  static bool gStateBlink = false;
  if (millis() - gPrevBlink > 100) {
    gPrevBlink = millis();
    gStateBlink = !gStateBlink;
    digitalWrite(pl.greenLED, gStateBlink);
  }
}

// --- Guess evaluation --- //
bool commitShot(PlayerHW &pl) {
  int check = 0;
  bool shipSunk = true;

  if (pl.inputRow < 0 || pl.inputRow > 9 || pl.inputCol < 0 || pl.inputCol > 9)
    return false;

  Board &enemy = boards[otherPlayer(activePlayer)];

  if (enemy.found[pl.inputRow][pl.inputCol]){
    endTurn();
    return false;
  }

  refreshOceanColors(pl);
  refreshAimColors(pl);

  if (enemy.ships[pl.inputRow][pl.inputCol] != 0 && enemy.ships[pl.inputRow][pl.inputCol] != 1) {
    enemy.found[pl.inputRow][pl.inputCol] = true;
    check = enemy.ships[pl.inputRow][pl.inputCol];
    Serial.print("check: ");
    Serial.println(check);
    enemy.ships[pl.inputRow][pl.inputCol] = 1;
    for(uint8_t y = 0; y < boardSize; y++){
      for(uint8_t x = 0; x < boardSize; x++){
        if(enemy.ships[y][x] == check){
          //break;
          shipSunk = false;
        }
      }
    }
    if(shipSunk == true){
      audioFile = Sunk_Sound;
    } else {
      audioFile = Hit_Sound;
    }
    delay(1);
    xTaskCreate(HitTaskCode, "hitTask", 10000, NULL, 1, &hitTask);
    if(shipSunk == true){
      switch(check){
        case orca:
          audioFile = Orca_Sound;
        break;
        case sub:
          audioFile = Sub_Sound;
        break;
        case AOPS:
          audioFile = AOPS_Sound;
        break;
        case frigate:
          audioFile = Halifax_Sound;
        break;
        case JSS:
          audioFile = JSS_Sound;
        break;
      }
    }
    enemy.remaining--;
    Serial.println(enemy.remaining);
    if (enemy.remaining == 0) {
      gameState = GAME_OVER;
      winSequence();
    }

    return true;   // HIT
  }
  audioFile = Miss_Sound;
  xTaskCreate(MissTaskCode, "missTask", 10000, NULL, 0, &missTask);
  return false;    // MISS
}


// 8×8 Matrix helpers
void hitLightUp(PlayerHW &pl, int r, int c) {
  pl.strip1.setPixelColor(indexConvert(r, c), 255, 0, 0);
  pl.strip2.setPixelColor(indexConvert(r, c), 255, 0, 0);
  saveColors(pl);
  startRipple(pl, r, c);
  stripUpdate = true;
  //delay(500);
  gameState = WAITING_FOR_AIM;
}

void missLightUp(PlayerHW &pl, int r, int c) {
  pl.strip1.setPixelColor(indexConvert(r, c), 127, 127, 127);
  pl.strip2.setPixelColor(indexConvert(r, c), 127, 127, 127);
  saveColors(pl);
  startRipple(pl, r, c);
  stripUpdate = true;
  endTurn();
}

int indexConvert(int r, int c){
  int x = 0;
  if(r % 2 == 0){
  x = ((r*10) + c);
  } else {
  x = ((r*10) + (9-c));
  }
  return x;
}

int getPosition(int positionPin){
    // Read the analog value (0-4095 on ESP32 ADC)
  int positionValue = -1;
  int readValue = 0;
  sensorValue = 0;
  int positionAverage = 0;

  while(positionValue != positionAverage){
    for(int i = 0; i < 5; i++){

      sensorValue = analogRead(positionPin);
      //Serial.println(sensorValue);


    // Map the value to a specific position (adjust ranges based on your resistor values)
      if (sensorValue < 210) positionValue = 9;
      else if (sensorValue < 635) positionValue = 8;
      else if (sensorValue < 1070) positionValue = 7;
      else if (sensorValue < 1510) positionValue = 6;
      else if (sensorValue < 1960) positionValue = 5;
      else if (sensorValue < 2400) positionValue = 4;
      else if (sensorValue < 2860) positionValue = 3;
      else if (sensorValue < 3380) positionValue = 2;
      else if (sensorValue < 4050) positionValue = 1;
      else if (sensorValue > 4051) positionValue = 0;

      positionAverage += positionValue;

    }
   
    if(positionAverage % 5 == 0){
      positionAverage = positionAverage/5;
    } else {
      positionAverage = 0;
    }

  }

  return positionValue;
}

bool buttonPressed(int pin) {
  static unsigned long lastTime[100];
  static bool lastState[100];

  bool reading = !digitalRead(pin);
  unsigned long now = millis();

  if (reading != lastState[pin] && now - lastTime[pin] > 100) {
    lastTime[pin] = now;
    lastState[pin] = reading;
    return reading;
  }
  return false;
}

// ===== Playback =====
static bool playWav(const char *path) {
  File f = LittleFS.open(path, "r");
  if (!f) { Serial.printf("Missing: %s\n", path); return false; }

  WavInfo w;
  if (!parseWav(f, w)) {
    // Helpful: distinguish RIFF vs other format
    f.seek(0);
    uint8_t h[4]; f.read(h,4);
    if (memcmp(h,"RIFF",4)!=0) Serial.printf("Not RIFF: %s\n", path);
    else Serial.printf("Bad WAV fmt (need mono 16-bit PCM): %s\n", path);
    f.close();
    return false;
  }

  setupI2S(w.sampleRate);
  f.seek(w.dataOffset);

  uint8_t buf[512];
  int16_t out[512]; // 256 frames * 2ch
  uint32_t left = w.dataSize;

  while (left) {
    //float vol = analogRead(POT_PIN) / 4095.0f;

    int n = f.read(buf, min((uint32_t)sizeof(buf), left));
    if (n <= 0) break;
    left -= n;

    int frames = 0;
    for (int i = 0; i + 1 < n && frames < 256; i += 2) {
      int16_t s = (int16_t)(buf[i] | (buf[i + 1] << 8));
      int32_t v = (int32_t)(s * volume);
      v = constrain(v, -32768, 32767);
      out[frames * 2]     = (int16_t)v; // L
      out[frames * 2 + 1] = (int16_t)v; // R (duplicate mono)
      frames++;
    }
    taskYIELD();
    size_t written;
    i2s_write(I2S_NUM_0, out, frames * 2 * sizeof(int16_t), &written, portMAX_DELAY);
  }

  f.close();
  return true;
}

bool playWavRam(const WavRam& w) {
  if (!w.data || !w.len) return false;

  setupI2S(w.sampleRate);

  const uint8_t* p = w.data;
  uint32_t left = w.len;

  int16_t outBuf[512]; // 256 frames stereo
  while (left) {
    int n = (left > 512) ? 512 : left;
    left -= n;

    int frames = 0;
    for (int i = 0; i + 1 < n && frames < 256; i += 2) {
      int16_t s = (int16_t)(p[i] | (p[i+1] << 8));
      int32_t v = (int32_t)(s * volume);
      v = constrain(v, -32768, 32767);
      outBuf[frames*2]   = (int16_t)v;
      outBuf[frames*2+1] = (int16_t)v;
      frames++;
    }
    p += n;

    size_t written;
    i2s_write(I2S_NUM_0, outBuf, frames * 2 * sizeof(int16_t), &written, portMAX_DELAY);
  }
  return true;
}

static void setupI2S(uint32_t sampleRate) {
  if (g_rate == sampleRate && sampleRate != 0) return;
  g_rate = sampleRate;

  i2s_driver_uninstall(I2S_NUM_0);

  i2s_config_t cfg = {};
  cfg.mode = (i2s_mode_t)(I2S_MODE_MASTER | I2S_MODE_TX);
  cfg.sample_rate = sampleRate;
  cfg.bits_per_sample = I2S_BITS_PER_SAMPLE_16BIT;
  cfg.channel_format = I2S_CHANNEL_FMT_RIGHT_LEFT;     // we will duplicate mono to L/R
  cfg.communication_format = I2S_COMM_FORMAT_STAND_I2S;
  cfg.dma_buf_count = 8;
  cfg.dma_buf_len = 256;
  cfg.use_apll = false;
  cfg.tx_desc_auto_clear = true;

  i2s_pin_config_t pins = {};
  pins.bck_io_num = I2S_BCLK;
  pins.ws_io_num  = I2S_LRC;
  pins.data_out_num = I2S_DOUT;
  pins.data_in_num  = I2S_PIN_NO_CHANGE;

  i2s_driver_install(I2S_NUM_0, &cfg, 0, NULL);
  i2s_set_pin(I2S_NUM_0, &pins);
  i2s_zero_dma_buffer(I2S_NUM_0);
}

static uint32_t readLE32(File &f) {
  uint8_t b[4];
  if (f.read(b, 4) != 4) return 0;
  return (uint32_t)b[0] | ((uint32_t)b[1] << 8) | ((uint32_t)b[2] << 16) | ((uint32_t)b[3] << 24);
}
static uint16_t readLE16(File &f) {
  uint8_t b[2];
  if (f.read(b, 2) != 2) return 0;
  return (uint16_t)b[0] | ((uint16_t)b[1] << 8);
}

static bool parseWav(File &f, WavInfo &w) {
  w = WavInfo{};
  f.seek(0);

  uint8_t id[4];
  if (f.read(id, 4) != 4 || memcmp(id, "RIFF", 4) != 0) return false;
  readLE32(f); // file size
  if (f.read(id, 4) != 4 || memcmp(id, "WAVE", 4) != 0) return false;

  bool gotFmt = false, gotData = false;

  while (f.available()) {
    if (f.read(id, 4) != 4) break;
    uint32_t size = readLE32(f);

    if (memcmp(id, "fmt ", 4) == 0) {
      uint16_t audioFormat = readLE16(f);
      w.numChannels = readLE16(f);
      w.sampleRate = readLE32(f);
      readLE32(f); // uint8_tRate
      readLE16(f); // blockAlign
      w.bitsPerSample = readLE16(f);

      //Serial.print("Sample Rate: ");
      //Serial.println(w.sampleRate);
      //Serial.print("Channels: ");
      //Serial.println(w.numChannels);

      // skip any extra fmt uint8_tsg
      if (size > 16) f.seek(f.position() + (size - 16));

      // Only support PCM, 16-bit, mono
      if (audioFormat != 1 || w.bitsPerSample != 16 || w.numChannels != 1) return false;
      gotFmt = true;
    }
    else if (memcmp(id, "data", 4) == 0) {
      w.dataOffset = f.position();
      w.dataSize = size;
      gotData = true;
      break;
    }
    else {
      f.seek(f.position() + size);
    }

    if (size & 1) f.seek(f.position() + 1); // word align
  }

  return gotFmt && gotData;
}


// --- Win sequence --- //
void winSequence() {
  Serial.println("All targets found! You win!");
  audioFile = Fleet_Destroyed_Sound;
  audioFile = Victory_Sound;
}

void detectShipPositions(Board &b, Adafruit_MCP23X17 mcpDevice[]){
  //memset(b.ships, 0, sizeof(b.ships));
  //memset(b.found, 0, sizeof(b.found));
  //initilizeGPIOPins();
  b.remaining = 0;
  uint8_t numberOfShips = 0;
  uint8_t gpioPinActive = -1; //This is the pin that is set LOW.
  uint8_t gpioPinShort = -1;
  uint8_t gpioPinShortTemp = -1;
  bool specialThree = false;
  bool finalCheck = false;

  for(uint8_t y = 0; y < boardSize; y++){
    for(uint8_t x = 0; x < boardSize; x++){
      b.ships[y][x] = 0;
      b.found[y][x] = 0;
    }
  }
  //Serial.print("numberOfShips: ");
  //Serial.println(numberOfShips);
  //printShipPositions();
  
  while(numberOfShips < 5){
    //Serial.print("numberOfShips: ");
    //Serial.println(numberOfShips);
    for(uint8_t row = 0; row < boardSize; row++){
      for(uint8_t column = 0; column < boardSize; column++){

        gpioPinActive = gpioPinArray[row][column];
        uint8_t activeDevice = gpioDeviceArray[row][column];

        //Drive current pin LOW
        mcpDevice[activeDevice].pinMode(gpioPinActive, OUTPUT);
        mcpDevice[activeDevice].digitalWrite(gpioPinActive, LOW);
        
        //Horizontal scan
        for(uint8_t i = 1; i <= maxShipSize && (column + i) < boardSize; i++){
          uint8_t device = gpioDeviceArray[row][column + i];
          uint8_t pin = gpioPinArray[row][column + i];

          mcpDevice[device].pinMode(pin, INPUT_PULLUP);
          gpioPinShort = mcpDevice[device].digitalRead(pin);
          if(gpioPinShort == LOW && b.ships[row][column + i] == EMPTY){
            numberOfShips++;
            //Serial.print("numberOfShips: ");
            //Serial.println(numberOfShips);
            
            if(i == 2){
              uint8_t newPin = gpioPinArray[row][column + 1];
              uint8_t newDevice = gpioDeviceArray[row][column + 1];
              mcpDevice[newDevice].pinMode(newPin, INPUT_PULLUP);
              gpioPinShort = mcpDevice[newDevice].digitalRead(newPin);
              if(gpioPinShort == LOW){ //Found special 3!
                specialThree = true;
                numberOfShips--;
                //Serial.print("numberOfShips: ");
                //Serial.println(numberOfShips);
              }
            }

            if(specialThree == true){
              for(uint8_t x = column; x <= (column + i); x++){
                b.ships[row][x] = 6;
                specialThree = false;
                //Serial.print("specialThree: ");
                //Serial.println(6);
              }
            }
            else{
              for(uint8_t x = column; x <= (column + i); x++){
                b.ships[row][x] = i + 1; //i should be 2-5.
                //Serial.print("i + 1: ");
                //Serial.println(i + 1);
              }
            }
          }          
        }
        
        //Vertical scan
        for(uint8_t i = 1; i <= maxShipSize && (row + i) < boardSize; i++){
          uint8_t device = gpioDeviceArray[row + i][column];
          uint8_t pin = gpioPinArray[row + i][column];

          mcpDevice[device].pinMode(pin, INPUT_PULLUP);
          gpioPinShort = mcpDevice[device].digitalRead(pin);
          
          if(gpioPinShort == LOW && b.ships[row + i][column] == EMPTY){ //Ship detected
            numberOfShips++;
            //Serial.print("numberOfShips: ");
            //Serial.println(numberOfShips);

            if(i == 2){
              uint8_t newPin = gpioPinArray[row + 1][column];
              uint8_t newDevice = gpioDeviceArray[row + 1][column];
              mcpDevice[newDevice].pinMode(newPin, INPUT_PULLUP);
              gpioPinShort = mcpDevice[newDevice].digitalRead(newPin);
              if(gpioPinShort == LOW){ //Found special 3!
                specialThree = true;
                numberOfShips--;
                //Serial.print("numberOfShips: ");
                //Serial.println(numberOfShips);
              }
            }

            if(specialThree == true){
              for(uint8_t y = row; y <= (row + i); y++){
                b.ships[y][column] = 6;
                specialThree = false;
                //Serial.print("specialThree: ");
                //Serial.println(6);
              }
            }
            else{
              for(uint8_t y = row; y <= (row + i); y++){
                b.ships[y][column] = i + 1; //i should be 2-5.
                //Serial.print("i + 1: ");
                //Serial.println(i + 1);
              }
            }
          }
        }
        mcpDevice[activeDevice].pinMode(gpioPinActive, INPUT_PULLUP);
      }
    }
    //printShipPositions();
    
    if(numberOfShips >= 5 && finalCheck == false){
      finalCheck = true;
      numberOfShips = 0;
      for(uint8_t y = 0; y < boardSize; y++){
        for(uint8_t x = 0; x < boardSize; x++){
          b.ships[y][x] = 0;
        }
      }
      delay(250);
    }

    /*if(numberOfShips >= 5){
      uint8_t threeCheck = 0;
      for(uint8_t y = 0; y < boardSize; y++){
        for(uint8_t x = 0; x < boardSize; x++){
          if(b.ships[y][x] == 3){
            threeCheck += threeCheck;
            if(threeCheck > 3 || numberOfShips > 5){
              numberOfShips = 0;
              for(uint8_t y = 0; y < boardSize; y++){
                for(uint8_t x = 0; x < boardSize; x++){
                  b.ships[y][x] = 0;
                }
              }
            }
          }
        }
      }
    }*/
  }
  //Serial.print("numberOfShips: ");
  //Serial.println(numberOfShips);
  b.remaining = 17;
}

void printShipPositions(){
  /*
  Serial.print("board 0 remaining: ");
  Serial.println(boards[0].remaining);
  Serial.print("board 1 remaining: ");
  Serial.println(boards[1].remaining);
  */
  for(int i = 0; i < 2; i++){
    Serial.println();
    for(uint8_t y = 0; y < 10; y++){
      for(uint8_t x = 0; x < 10; x++){
        Serial.print(boards[i].ships[y][x]);
        Serial.print(", ");
        if(x == 9){
          Serial.println();
        }
      }
    }
  }
}

void initilizeGPIOPins(){
  //delay(5000);
  for(uint8_t i = 0; i < 7; i++){
    for(uint8_t j = 0; j < 14; j++){
      mcp0[i].pinMode(j, INPUT_PULLUP);
      Serial.print("Player 2: ");
      Serial.print("Initialized: ");
      Serial.print(j);
      Serial.print(" on chip: ");
      Serial.println(i);
    }
  }
  
  for(uint8_t i = 0; i < 7; i++){
    for(uint8_t j = 0; j < 14; j++){
      mcp1[i].pinMode(j, INPUT_PULLUP);
      Serial.print("Player 2: ");
      Serial.print("Initialized: ");
      Serial.print(j);
      Serial.print(" on chip: ");
      Serial.println(i);
    }
  }
}

void startOcean() {
  oceanActive = true;
  oceanTime = 0.0;
  lastOceanUpdate = millis();
}

void updateOcean() {
  if (!oceanActive) return;

  // Faster frame rate (~40 FPS)
  if (millis() - lastOceanUpdate < 100) return;
  lastOceanUpdate = millis();
  refreshOceanColors(players[0]);
  refreshOceanColors(players[1]);

  for (int r = 0; r < 10; r++) {
    for (int c = 0; c < 10; c++) {

      int idx = indexConvert(r, c);
      uint32_t base = players[0].previousColors1[idx];

      uint8_t br = (base >> 16) & 0xFF;
      uint8_t bg = (base >> 8) & 0xFF;
      uint8_t bb = base & 0xFF;

      // Only affect blue tiles
      if (br == 0 && bg == 0 && bb > 0) {

        // Large slow swells
        float swell1 = sin(oceanTime * 0.6 + r * 0.7 + c * 0.3);
        float swell2 = sin(oceanTime * 0.4 + r * 0.2 - c * 0.8);

        // Medium waves
        float wave1 = sin(oceanTime * 1.3 + r * 1.2);
        float wave2 = sin(oceanTime * 1.1 + c * 1.4);

        // Small fast ripples
        float ripple1 = sin(oceanTime * 2.4 + (r + c) * 1.8);
        float ripple2 = sin(oceanTime * 2.8 + (r - c) * 1.5);
        float mix;

        // Combine all layers
        if(storm == 0){
          mix =
          swell1 * 0.35 +
          swell2 * 0.25 +
          wave1  * 0.20 +
          wave2  * 0.15 +
          ripple1 * 0.03 +
          ripple2 * 0.02;
        } else if(storm == 1){
          mix =
          swell1 * 0.35 +
          swell2 * 0.25 +
          wave1  * 0.20 +
          wave2  * 0.15 +
          ripple1 * 0.06 +
          ripple2 * 0.05;
        }

        // Normalize
        float level = (mix + 1.2) * 0.45;

        if (level < 0) level = 0;
        if (level > 1) level = 1;

        // Deep water color
        int blue = (int)(level * 170) + 40;

        // Foam on strong peaks
        int foam = 0;
        if (level > 0.82) {
          foam = (int)((level - 0.82) * 700);
          if (foam > 100) foam = 100;
        }

        // Slight random shimmer
        foam += random(-5, 6);
        if (foam < 0) foam = 0;

        // Final color
        int rCol = foam;
        int gCol = foam;
        int bCol = min(255, blue + foam);

        players[0].strip1.setPixelColor(idx, rCol, gCol, bCol);
      }
    }
  }
  for (int r = 0; r < 10; r++) {
    for (int c = 0; c < 10; c++) {

      int idx = indexConvert(r, c);
      uint32_t base = players[1].previousColors1[idx];

      uint8_t br = (base >> 16) & 0xFF;
      uint8_t bg = (base >> 8) & 0xFF;
      uint8_t bb = base & 0xFF;

      // Only affect blue tiles
      if (br == 0 && bg == 0 && bb > 0) {

        // Large slow swells
        float swell1 = sin(oceanTime * 0.6 + r * 0.7 + c * 0.3);
        float swell2 = sin(oceanTime * 0.4 + r * 0.2 - c * 0.8);

        // Medium waves
        float wave1 = sin(oceanTime * 1.3 + r * 1.2);
        float wave2 = sin(oceanTime * 1.1 + c * 1.4);

        // Small fast ripples
        float ripple1 = sin(oceanTime * 2.4 + (r + c) * 1.8);
        float ripple2 = sin(oceanTime * 2.8 + (r - c) * 1.5);
        float mix;

        // Combine all layers
        if(storm == 0){
          mix =
          swell1 * 0.35 +
          swell2 * 0.25 +
          wave1  * 0.20 +
          wave2  * 0.15 +
          ripple1 * 0.03 +
          ripple2 * 0.02;
        } else if(storm == 1){
          mix =
          swell1 * 0.35 +
          swell2 * 0.25 +
          wave1  * 0.20 +
          wave2  * 0.15 +
          ripple1 * 0.06 +
          ripple2 * 0.05;
        }

        // Normalize
        float level = (mix + 1.2) * 0.45;

        if (level < 0) level = 0;
        if (level > 1) level = 1;

        // Deep water color
        int blue = (int)(level * 170) + 40;

        // Foam on strong peaks
        int foam = 0;
        if (level > 0.82) {
          foam = (int)((level - 0.82) * 700);
          if (foam > 100) foam = 100;
        }

        // Slight random shimmer
        foam += random(-5, 6);
        if (foam < 0) foam = 0;

        // Final color
        int rCol = foam;
        int gCol = foam;
        int bCol = min(255, blue + foam);

        players[1].strip1.setPixelColor(idx, rCol, gCol, bCol);
      }
    }  
  }
  oceanTime += 0.14;
  stripUpdate = true;
}

void startRipple(PlayerHW &pl, int r, int c) {
  rippleActive = true;
  rippleRow = r;
  rippleCol = c;
  
  ripplePlayer = activePlayer;

  rippleRadius = 0.0;
  rippleStrength = 1.0;

  lastRippleUpdate = millis();
}

void updateRipple() {
  if (!rippleActive) return;

  // Frame rate (~40 FPS)
  if (millis() - lastRippleUpdate < 25) return;
  lastRippleUpdate = millis();

  for (int r = 0; r < 10; r++) {
    for (int c = 0; c < 10; c++) {

      int idx = indexConvert(r, c);

      // Read CURRENT pixel (already has ocean)
      uint32_t cur = players[ripplePlayer].strip1.getPixelColor(idx);

      uint8_t cr = (cur >> 16) & 0xFF;
      uint8_t cg = (cur >> 8) & 0xFF;
      uint8_t cb = cur & 0xFF;

      // Distance from impact
      float dist = sqrt(
        (r - rippleRow) * (r - rippleRow) +
        (c - rippleCol) * (c - rippleCol)
      );

      float band = 0.7;
      float diff = abs(dist - rippleRadius);

      if (diff < band) {

        float fade = (1.0 - diff / band) * rippleStrength;
        if (fade < 0) fade = 0;

        int glow = (int)(fade * 180);

        // Add glow on top (not replace)
        cr = min(255, cr + glow / 2);
        cg = min(255, cg + glow / 2);
        cb = min(255, cb + glow);

        players[ripplePlayer].strip1.setPixelColor(idx, cr, cg, cb);
      }
    }
  }
  stripUpdate = true;

  // Expand & fade
  rippleRadius += 0.4;
  rippleStrength *= 0.93;

  if (rippleStrength < 0.05 || rippleRadius > 15) {
    rippleActive = false;
  }
}

void setVolume(){
  int volPosition = getPosition(P1_POT_COL);

  while(digitalRead(P1_RED_BTN) == HIGH){
      
    blinkIndicatorR(players[0]);
    if(audioFile == -1){
      volume = 1 - (analogRead(P1_POT_COL) / 4095.0f);
    }
    //Serial.println(volume);
    if(getPosition(P1_POT_COL) != volPosition){
      audioFile = Bloop_Sound;
      volPosition = getPosition(P1_POT_COL);
    }
  }
  digitalWrite(P1_RED_LED, HIGH);
}

void setBrightness(){
  while(digitalRead(P1_GREEN_BTN) == HIGH){
    blinkIndicatorG(players[0]);
    int brightPot = getPosition(P1_POT_ROW);
    switch (brightPot){
      case 0:
      brightness = 0;
      break;
      case 1:
      brightness = 25;
      break;
      case 2:
      brightness = 55;
      break;
      case 3:
      brightness = 80;
      break;
      case 4:
      brightness = 105;
      break;
      case 5:
      brightness = 130;
      break;
      case 6:
      brightness = 155;
      break;
      case 7:
      brightness = 180;      
      break;
      case 8:
      brightness = 205;
      break;
      case 9:
      brightness = 255;
      break;
    }
    //Serial.println(brightness);

    for(int p = 0; p < 2; p++){
      players[p].strip1.clear();
      players[p].strip2.clear();
      for (int i = 0; i < LED_COUNT; i++) {
          players[p].strip1.setPixelColor(i, 0, 0, 255);
        }
      for (int i = 0; i < LED_COUNT; i++) {
          players[p].strip2.setPixelColor(i, 5, 75, 5);
        }
      players[p].strip1.setBrightness(brightness);
      players[p].strip2.setBrightness(brightness);
      players[p].strip1.show();
      players[p].strip2.show();
    }
  }
  digitalWrite(P1_GREEN_LED, HIGH);
}

bool loadWavToRam(const char* path, WavRam& out) {
  File f = LittleFS.open(path, "r");
  if (!f) return false;

  WavInfo w;
  if (!parseWav(f, w)) { f.close(); return false; }

  out.sampleRate = w.sampleRate;
  out.len = w.dataSize;

  // If you have PSRAM, use ps_malloc; otherwise malloc.
  out.data = (uint8_t*)malloc(out.len);
  if (!out.data) { f.close(); return false; }

  f.seek(w.dataOffset);
  size_t got = f.read(out.data, out.len);
  f.close();

  return got == out.len;
}
